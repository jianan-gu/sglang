#include <ATen/ATen.h>
#include <ATen/Parallel.h>
#include <c10/xpu/XPUStream.h>
#include <torch/python.h>

#include <cmath>
#include <cstdint>
#include <iostream>
#include <sycl/sycl.hpp>
#include <vector>

#include "SYCLHelpers.h"
//#include "esimd_mul.h"

#include <sycl/sycl.hpp>
#include <sycl/ext/intel/esimd.hpp>

using namespace sycl::ext::intel::esimd;
using namespace sycl::ext::intel::esimd::xmx;
using fp16 = sycl::half;
using namespace sycl;

ESIMD_INLINE void esimd_mul_impl(uint8_t* a, uint8_t* b, uint8_t* c, int64_t len, nd_item<1>& ndi) {

  __ESIMD_NS::slm_init(16 * sizeof(fp16)); 

  int global_idx = ndi.get_group(0);
  int local_range = ndi.get_local_range(0);
  int local_idx = ndi.get_local_id(0);
  int inputOffset = (global_idx * local_range + local_idx) * 128 * sizeof(fp16);
  simd<fp16, 128> a_fp16;
  simd<fp16, 128> b_fp16;
  simd<fp16, 128> c_fp16;


      a_fp16.template bit_cast_view<uint8_t>().template select<256, 1>(0) =
              __ESIMD_ENS::lsc_block_load<
              uint8_t,
              256,
              __ESIMD_ENS::lsc_data_size::default_size,
              __ESIMD_ENS::cache_hint::cached,
              __ESIMD_ENS::cache_hint::cached>((uint8_t*)a + inputOffset);

      b_fp16.template bit_cast_view<uint8_t>().template select<256, 1>(0) =
              __ESIMD_ENS::lsc_block_load<
              uint8_t,
              256,
              __ESIMD_ENS::lsc_data_size::default_size,
              __ESIMD_ENS::cache_hint::cached,
              __ESIMD_ENS::cache_hint::cached>((uint8_t*)b + inputOffset);

      c_fp16 = a_fp16 * b_fp16;

    // if (local_idx < 16)
    {
      __ESIMD_ENS::lsc_block_store<
        fp16,
        128,
        __ESIMD_ENS::lsc_data_size::default_size,
        __ESIMD_ENS::cache_hint::write_back,
        __ESIMD_ENS::cache_hint::write_back>((fp16*)c + 128 * (global_idx * local_range + local_idx), c_fp16.select<128, 1>(0));
    }
    barrier();
    
}

void esimd_mul(uint8_t* a, uint8_t* b, uint8_t* c, int64_t len, sycl::queue& q){
    sycl::range<1> LocalRange(16); 
    sycl::range<1> GlobalRange(len / 128);

    sycl::nd_range<1> Range(GlobalRange, LocalRange);
    printf("--- global, local: %d, %d\n", 16, len / 128);
    sycl::event e;
    try {
      {
        e = q.submit([&](handler& cgh) {
        cgh.parallel_for(Range, [=](nd_item<1> ndi) SYCL_ESIMD_KERNEL{
              esimd_mul_impl(a, b, c, len, ndi);
            });
         });
      }
    } catch (sycl::exception const &e) {
      std::cout << "SYCL exception caught: " << e.what() << '\n';
      return;
    }
}

at::Tensor esimd_kernel_mul_lgrf(
    at::Tensor _p0,
    at::Tensor _p1,
    at::Tensor _p2,
    //at::Tensor _p3,
    //at::Tensor _p4,
    //at::Tensor _p5,
    //at::Tensor _p6,
    //at::Tensor _p7,
    //at::Tensor _p8,
    //at::Tensor _p9,

    int64_t i0,
    int64_t i1
    //int64_t i2,
    //int64_t i3,
    //int64_t i4,
    //int64_t i5,
    //int64_t i6,
    //int64_t i7,
    //int64_t i8,
    //int64_t i9,

    //float f0,
    //float f1,
    //float f2,
    //float f3,
    //float f4
    )
    {
    auto p0 = reinterpret_cast<uint8_t*>(_p0.data_ptr<at::Half>());
    auto p1 = reinterpret_cast<uint8_t*>(_p1.data_ptr<at::Half>());
    auto p2 = reinterpret_cast<uint8_t*>(_p2.data_ptr<at::Half>());
    //auto p3 = reinterpret_cast<uint8_t*>(_p3.data_ptr<uint8_t>());
    //auto p4 = reinterpret_cast<uint8_t*>(_p4.data_ptr<uint8_t>());
    //auto p5 = reinterpret_cast<uint8_t*>(_p5.data_ptr<uint8_t>());
    //auto p6 = reinterpret_cast<uint8_t*>(_p6.data_ptr<uint8_t>());
    //auto p7 = reinterpret_cast<uint8_t*>(_p7.data_ptr<uint8_t>());
    //auto p8 = reinterpret_cast<uint8_t*>(_p8.data_ptr<uint8_t>());
    //auto p9 = reinterpret_cast<uint8_t*>(_p9.data_ptr<uint8_t>());
    auto stream = at::xpu::getCurrentXPUStream();
    auto dpcpp_queue = stream.queue();

      switch(i0){
        case 1000:   // rms norm
          esimd_mul(p0, p1, p2, i1, dpcpp_queue);
          break;
        default:
          printf("---------- esimd uni-lgrf kernel op not supported, op is %lld ----------\n", i0);
          break;
      }
      return _p2;
    }